# PGO 101 - Chapter 1 이론 강의: 3D 공간의 언어, 회전과 변환

**강의 목표:** 이 강의를 마치면, 여러분은 3차원 공간에서 로봇의 움직임과 자세를 수학적으로 어떻게 표현하고 계산하는지 이해하게 됩니다. 특히, Pose Graph Optimization의 가장 기본이 되는 **회전(Rotation)**과 **자세(Pose)**의 다양한 표현법을 배우고, 이들이 왜 중요한지, 그리고 어떤 상황에 어떤 방법을 사용해야 하는지 설명할 수 있게 됩니다. 이 강의는 `chapter01_rotation_and_se3_basics.ipynb` 실습을 위한 탄탄한 이론적 기반을 제공합니다.

---

## 1. 왜 3D 공간 표현이 중요한가?

로봇, 드론, 자율주행차, AR 글래스 등 우리가 다루는 대부분의 시스템은 3차원 공간에서 움직입니다. 이들의 움직임을 정확하게 기술하고 예측하며, 센서 데이터를 해석하기 위해서는 3D 공간을 표현하는 일관되고 강건한 '언어'가 필요합니다.

> 💡 **핵심 질문**: "로봇의 현재 위치와 방향(자세)은 무엇인가?" 그리고 "로봇이 다음 위치로 어떻게 움직였는가?"

이 질문에 답하는 것이 바로 3D 공간 변환의 핵심입니다. 잘못된 표현법을 사용하면 **짐벌락(Gimbal Lock)**과 같은 치명적인 문제에 부딪히거나, 작은 계산 오차가 누적되어 로봇이 자신의 위치를 완전히 잃어버릴 수 있습니다.

## 2. 회전(Rotation) 표현법: 방향을 나타내는 다양한 방법

로봇의 '방향' 또는 '자세'를 표현하는 방법은 여러 가지가 있으며, 각각 장단점이 뚜렷합니다.

### 개념 트리: 회전 표현법

*   **회전 (Rotation, $SO(3)$ 그룹)**
    *   **개념**: 3차원 공간에서의 방향. 3개의 자유도(Degree of Freedom, DoF)를 가짐.
    *   **표현 방식**
        *   **회전 행렬 (Rotation Matrix)**
            *   *선수 지식*: 선형대수 (행렬, 벡터, 행렬 곱셈)
            *   **정의**: 3x3 직교 행렬 ($R^T R = I$)이며, 행렬식(determinant)이 +1.
            *   **장점**: 직관적, 변환 적용이 간단함 (벡터에 행렬 곱).
            *   **단점**: 9개 숫자로 3개의 자유도를 표현 (과다 표현, Redundant), 수치 오차로 직교성이 깨질 수 있음.
        *   **쿼터니언 (Quaternion)**
            *   *선수 지식*: 복소수 개념 (이 강의에서 새로 소개)
            *   **정의**: 4개의 숫자로 구성된 복소수 확장판 ($q = q_w + q_x i + q_y j + q_z k$).
            *   **장점**: **짐벌락 없음**, 메모리 효율적, 부드러운 보간(SLERP) 가능.
            *   **단점**: 직관적 이해가 어려움.
        *   **회전 벡터 (Rotation Vector / Axis-Angle)**
            *   *선수 지식*: 벡터, 벡터의 노름(norm)
            *   **정의**: 3차원 벡터. 벡터의 **방향**이 회전축, 벡터의 **크기**가 회전 각도($\theta$).
            *   **장점**: **최소 표현(3 DoF)**, 최적화 문제의 변수로 사용하기에 가장 적합 (접선 공간과 직접적 관련).
            *   **단점**: 여러 회전을 합성하는 연산이 복잡함.

> **⚠️ 짐벌락(Gimbal Lock)이란?**
> 오일러 각(Euler Angles, 예: Roll, Pitch, Yaw)과 같은 특정 표현법에서 발생하는 문제로, 회전축 중 두 개가 정렬되어 회전의 자유도 하나를 잃어버리는 현상입니다. 비행기나 우주선이 특정 자세에서 조종 불능에 빠지는 원인이 될 수 있습니다. 이 때문에 현대 로보틱스나 3D 그래픽스에서는 쿼터니언을 표준으로 사용합니다.

### [실습 연결]
`chapter01` 노트북의 **1. 회전 표현법 간 변환** 섹션에서는 `scipy` 라이브러리를 사용하여 방금 배운 세 가지 표현법(회전 행렬, 쿼터니언, 회전 벡터)을 서로 변환하는 코드를 실습합니다.

---

## 3. 자세(Pose) 표현법: SE(3) 변환

로봇의 상태를 완벽하게 표현하려면 방향(회전)뿐만 아니라 위치(이동)도 함께 알아야 합니다. 이 둘을 합친 것이 바로 **자세(Pose)**입니다.

### 개념 트리: 자세 표현법

*   **자세 (Pose, $SE(3)$ 그룹)**
    *   **개념**: 3차원 공간에서의 위치와 방향. 6개의 자유도(3-DoF 위치 + 3-DoF 방향)를 가짐.
    *   **표현 방식**: **동차 변환 행렬 (Homogeneous Transformation Matrix)**
        *   *선수 지식*: 블록 행렬(Block Matrix)
        *   **정의**: 4x4 행렬. 회전(R)과 이동(t) 정보를 하나로 결합.
            $$ T = \begin{bmatrix} R & t \\ 0 & 1 \end{bmatrix} $$
            *   $R$: 3x3 회전 행렬
            *   $t$: 3x1 이동 벡터
    *   **핵심 연산**
        *   **합성 (Composition)**: $T_{AC} = T_{AB} \cdot T_{BC}$ (두 변환을 순차적으로 적용)
        *   **역변환 (Inverse)**: $T_{BA} = T_{AB}^{-1}$ (변환을 되돌림)
        *   **점 변환 (Point Transformation)**: $p_A = T_{AB} \cdot p_B$ (B 좌표계의 점을 A 좌표계로 변환)

### [실습 연결]
`chapter01` 노트북의 **2. SE(3) 변환** 섹션에서는 `SE3Transform` 클래스를 직접 만들어, 자세의 합성과 역변환을 코드로 구현하고 그 결과를 시각화합니다.

---

## 4. 최적화의 시작: 매니폴드와 접선 공간

우리가 다루는 회전($SO(3)$)과 자세($SE(3)$)는 유클리드 공간처럼 평평하지 않고, 지구 표면처럼 '구부러진' 공간입니다. 이런 공간을 **매니폴드(Manifold)**라고 부릅니다.

**문제점**: 구부러진 공간에서는 일반적인 덧셈, 뺄셈이 의미가 없습니다. (예: 두 회전 행렬을 더하면 더 이상 회전 행렬이 아님) 하지만 우리가 사용할 최적화 알고리즘은 변수들이 평평한 벡터 공간에 있다고 가정합니다.

**해결책**: **접선 공간(Tangent Space)**을 도입합니다.

*   **매니폴드 (Manifold)**: 우리가 다루는 실제 공간 (예: 모든 가능한 회전들의 집합).
*   **접선 공간 (Tangent Space)**: 매니폴드의 한 점에 접하는 '평평한' 벡터 공간. 이 공간에서는 벡터의 덧셈, 뺄셈이 가능합니다. 최적화 과정에서 계산되는 작은 변화량($\Delta x$)이 바로 이 접선 공간의 벡터입니다.

> 💡 **핵심 비유**: 지구(매니폴드) 위를 걷는다고 상상해보세요. 지구 전체는 둥글지만, 당신이 서 있는 주변의 작은 영역(접선 공간)은 평평해 보입니다. 우리는 이 '평평한' 공간에서 움직임을 계산한 뒤, 그 결과를 다시 '둥근' 지구 위로 옮깁니다.

*   **Exponential Map (`exp`)**: 접선 공간의 벡터(작은 변화량)를 매니폴드 위의 실제 변환으로 매핑합니다.
*   **Logarithm Map (`log`)**: 매니폴드 위의 두 점 사이의 차이를 접선 공간의 벡터로 매핑합니다.

### [실습 연결]
`chapter01` 노트북의 **3. Tangent Space와 Manifold** 섹션에서는 `exp`와 `log` 연산을 코드로 구현하고, 이를 통해 최적화에서 포즈를 어떻게 업데이트하는지(`retract` 연산) 실습합니다. 이 개념은 앞으로 배울 모든 최적화 과정의 기초가 됩니다.
