# PGO 101 - Chapter 1 이론 강의: 3D 공간의 언어, 회전과 변환

**강의 목표:** 이 강의를 마치면, 여러분은 3차원 공간에서 로봇의 움직임과 자세를 수학적으로 어떻게 표현하고 계산하는지 이해하게 됩니다. 특히, Pose Graph Optimization의 가장 기본이 되는 **회전 (Rotation)** 과 **자세 (Pose)** 의 다양한 표현법을 배우고, 이들이 왜 중요한지, 그리고 어떤 상황에 어떤 방법을 사용해야 하는지 설명할 수 있게 됩니다. 이 강의는 `chapter01_rotation_and_se3_basics.ipynb` 실습을 위한 탄탄한 이론적 기반을 제공합니다.

---

## 1. 들어가기 앞서: 3D 공간과 변환의 기초

본격적인 회전과 변환을 배우기 전에, 기본이 되는 몇 가지 선수 지식을 짚고 넘어가겠습니다.

*   **좌표계 (Coordinate System)**: 우리가 이야기하는 모든 위치와 방향은 '기준'이 되는 좌표계 안에서 정의됩니다. 로보틱스에서는 주로 **오른손 좌표계**를 사용합니다. (오른손의 엄지, 검지, 중지를 각각 X, Y, Z 축으로 생각하면 됩니다.) 월드 (전역) 좌표계, 로봇 (바디) 좌표계, 센서 좌표계 등 다양한 좌표계가 존재하며, 이들 사이의 관계를 정의하는 것이 변환의 시작입니다.

*   **벡터 (Vector)**: 벡터는 크기와 방향을 가진 양입니다. 3D 공간에서 벡터는 주로 특정 좌표계의 원점으로부터의 '위치'를 나타내거나, 특정 방향으로의 '이동' 또는 '방향' 자체를 나타내는 데 사용됩니다.

*   **선형 변환 (Linear Transformation)**: 하나의 벡터를 다른 벡터로 매핑하는 함수입니다. 3D 공간에서의 회전, 크기 조절 (scaling) 등은 모두 선형 변환에 속하며, 이는 **행렬 (Matrix)** 로 표현될 수 있습니다. 벡터에 행렬을 곱하는 것은 해당 벡터에 선형 변환을 적용하는 것과 같습니다.

## 2. 회전 (Rotation) 표현법: $SO(3)$ 그룹

로봇의 '방향' 또는 '자세'를 표현하는 방법은 여러 가지가 있으며, 각각 장단점이 뚜렷합니다. 수학적으로, 3D 공간에서의 회전은 **특수 직교 그룹 (Special Orthogonal Group)**, 즉 $SO(3)$ 에 속하는 원소로 표현됩니다. 이는 3개의 **자유도 (Degree of Freedom, DoF)** 를 가집니다.

### 2.1. 회전 행렬 (Rotation Matrix)

**정의**: 회전 행렬은 $SO(3)$ 그룹의 가장 대표적인 표현법입니다. 3x3 크기의 행렬 $R$ 로, 다음 두 가지 핵심 조건을 만족합니다.

1.  **직교성 (Orthogonality)**: $R^T R = R R^T = I$ (여기서 $I$ 는 단위 행렬입니다). 이는 행렬의 행과 열 벡터들이 서로 직교하며 크기가 1임을 의미합니다.
2.  **양의 행렬식 (Positive Determinant)**: $\\det(R) = +1$ . 이 조건은 변환이 반사 (reflection) 를 포함하지 않는 순수한 회전임을 보장합니다.

$$
R \\in SO(3) \\equiv \\{ R \\in \\mathbb{R}^{3 \\times 3} \\mid R^T R = I, \\det(R) = 1 \\}
$$

-   **직관적 의미**: 월드 좌표계의 기저 벡터 (basis vectors) $( \\mathbf{e}_x, \\mathbf{e}_y, \\mathbf{e}_z )$ 가 회전 후 로봇의 좌표계에서 어떻게 보이는지를 나타냅니다. 즉, 행렬 $R$ 의 각 열은 변환된 기저 벡터가 됩니다.
-   **장점**:
    -   개념적으로 매우 직관적입니다.
    -   벡터에 회전을 적용하는 것이 간단한 행렬-벡터 곱으로 계산됩니다: $\\mathbf{v}_{\\text{rotated}} = R \\cdot \\mathbf{v}$ .
    -   여러 회전을 합성하는 것이 행렬 곱으로 간단하게 표현됩니다: $R_{\\text{total}} = R_2 \\cdot R_1$ .
-   **단점**:
    -   **과다 표현 (Over-parameterization)**: 3개의 자유도를 표현하기 위해 9개의 숫자를 사용하며, 6개의 제약 조건이 따릅니다. 이는 메모리 낭비와 계산 비효율을 야기합니다.
    -   **수치적 불안정성**: 반복적인 계산 과정에서 부동소수점 오차가 누적되면, 행렬이 직교성 ($R^T R = I$) 을 미세하게 잃어버릴 수 있습니다. 이를 방지하기 위해 주기적인 **정규화 (Normalization)** 과정이 필요합니다.

### 2.2. 회전 벡터 (Rotation Vector / Axis-Angle)

**정의**: 3차원 벡터 $\\mathbf{r} \\in \\mathbb{R}^3$ 하나로 회전을 표현하는 가장 간결한 방법입니다.
-   벡터의 **방향** ($\hat{\\mathbf{r}} = \\frac{\\mathbf{r}}{\\|\\mathbf{r}\\|}$) 이 회전축이 됩니다.
-   벡터의 **크기** ($\theta = \\|\\mathbf{r}\\|$) 가 해당 축을 중심으로 회전하는 각도 (라디안) 가 됩니다.

-   **장점**:
    -   **최소 표현 (Minimal Representation)**: 3개의 자유도를 정확히 3개의 숫자로 표현하여 메모리 효율이 매우 높습니다.
    -   최적화 문제에서 변수로 사용하기에 가장 적합합니다. 그 이유는 이것이 바로 아래에서 배울 **접선 공간 (Tangent Space)** 의 벡터와 직접적으로 대응되기 때문입니다.
-   **단점**:
    -   여러 회전을 합성하는 연산이 행렬 곱처럼 간단하지 않고, **로드리게스 회전 공식 (Rodrigues' Rotation Formula)** 과 같은 복잡한 계산이 필요합니다.
    -   $\theta = 0$ 또는 $\\theta = 2\\pi k$ 근처에서 특이점 (singularity) 이 존재할 수 있습니다.

### 2.3. 쿼터니언 (Quaternion)

**정의**: 쿼터니언은 4개의 실수로 구성된, 복소수를 확장한 개념입니다. 보통 하나의 스칼라 성분 ($q_w$) 과 3개의 벡터 성분 (\\mathbf{q}_v = [q_x, q_y, q_z]) 으로 표현됩니다.

$$
q = q_w + q_x i + q_y j + q_z k
$$

회전을 표현할 때는 크기가 1인 **단위 쿼터니언 (Unit Quaternion)** 을 사용합니다: $\\|q\\|^2 = q_w^2 + q_x^2 + q_y^2 + q_z^2 = 1$ .

-   **회전 벡터와의 관계**: 회전축이 $\\mathbf{u}$ , 회전 각도가 $\\theta$ 일 때, 해당하는 쿼터니언은 다음과 같습니다.
    $$
q = \\left( \\cos\\left(\\frac{\\theta}{2}\\right), \\sin\\left(\\frac{\\theta}{2}\\right)\\mathbf{u} \\right) = \\left[ \\cos\\left(\\frac{\\theta}{2}\\right), \\sin\\left(\\frac{\\theta}{2}\\right)u_x, \\sin\\left(\\frac{\\theta}{2}\\right)u_y, \\sin\\left(\\frac{\\theta}{2}\\right)u_z \\right]
$$
-   **장점**:
    -   **짐벌락이 없습니다.** 이는 3D 그래픽스, 항공 우주, 로보틱스에서 표준으로 사용되는 가장 큰 이유입니다.
    -   회전 행렬보다 메모리 효율적입니다 (4개 숫자).
    -   두 회전 사이를 부드럽게 보간 (Interpolation) 하는 **SLERP (Spherical Linear Interpolation)** 연산이 가능하여 애니메이션이나 경로 생성에 유리합니다.
-   **단점**:
    -   4개의 숫자로 표현되므로 직관적인 이해가 가장 어렵습니다.

> **⚠️ 짐벌락 (Gimbal Lock) 이란?**
> 오일러 각 (Euler Angles, 예: Roll, Pitch, Yaw) 과 같은 특정 표현법에서 발생하는 문제로, 회전축 중 두 개가 정렬되어 회전의 자유도 하나를 잃어버리는 현상입니다. 비행기나 우주선이 특정 자세에서 조종 불능에 빠지는 원인이 될 수 있습니다. 이 때문에 현대 로보틱스나 3D 그래픽스에서는 쿼터니언을 표준으로 사용합니다.

### [실습 연결]
`chapter01` 노트북의 **1. 회전 표현법 간 변환** 섹션에서는 `scipy` 라이브러리를 사용하여 방금 배운 세 가지 표현법 (회전 행렬, 쿼터니언, 회전 벡터) 을 서로 변환하는 코드를 실습합니다.

---

## 3. 자세 (Pose) 표현법: $SE(3)$ 변환

로봇의 상태를 완벽하게 표현하려면 방향 (회전) 뿐만 아니라 위치 (이동) 도 함께 알아야 합니다. 이 둘을 합친 것이 바로 **자세 (Pose)** 입니다. 수학적으로, 3D 공간에서의 자세는 **특수 유클리드 그룹 (Special Euclidean Group)**, 즉 $SE(3)$ 에 속하는 원소로 표현됩니다. 이는 6개의 자유도 (3-DoF 위치 + 3-DoF 방향) 를 가집니다.

### 3.1. 동차 변환 행렬 (Homogeneous Transformation Matrix)

**정의**: $SE(3)$ 변환은 보통 4x4 크기의 **동차 변환 행렬** $T$ 로 표현됩니다. 이 행렬은 회전 ($R$) 과 이동 (\\mathbf{t}) 정보를 하나의 행렬 안에 깔끔하게 담고 있습니다.

$$
T = \\begin{bmatrix} R & \\mathbf{t} \\\
\\mathbf{0}^T & 1 \\end{bmatrix} \\in SE(3)
$$

-   $R$: 3x3 회전 행렬 ($R \\in SO(3)$)
-   \\mathbf{t}: 3x1 이동 벡터 (\\mathbf{t} \\in \\mathbb{R}^3$)
-   \\mathbf{0}^T: `[0, 0, 0]` 행 벡터

### 3.2. $SE(3)$ 의 핵심 연산

-   **합성 (Composition)**: 두 변환을 순차적으로 적용하는 것은 행렬 곱으로 간단히 계산됩니다. A에서 B로, B에서 C로의 변환이 있을 때, A에서 C로의 변환은 다음과 같습니다.
    $$ T_{AC} = T_{AB} \\cdot T_{BC} $$
-   **역변환 (Inverse)**: 변환을 되돌리는 연산입니다. B에서 A로의 변환은 A에서 B로의 변환의 역행렬입니다.
    $$ T_{BA} = T_{AB}^{-1} = \\begin{bmatrix} R^T & -R^T \\mathbf{t} \\\
\\mathbf{0}^T & 1 \\end{bmatrix} $$
-   **점 변환 (Action on a point)**: B 좌표계에서 표현된 점 $\\mathbf{p}_B$ 를 A 좌표계의 점 $\\mathbf{p}_A$ 로 변환합니다. (점을 동차 좌표 `[x, y, z, 1]` 로 만들어 계산합니다.)
    $$ \\mathbf{p}_A = T_{AB} \\cdot \\mathbf{p}_B $$

### [실습 연결]
`chapter01` 노트북의 **2. SE(3) 변환** 섹션에서는 `SE3Transform` 클래스를 직접 만들어, 자세의 합성과 역변환을 코드로 구현하고 그 결과를 시각화합니다.

---

## 4. 최적화의 시작: 매니폴드와 접선 공간

우리가 다루는 회전 ($SO(3)$) 과 자세 ($SE(3)$) 는 유클리드 공간처럼 평평하지 않고, 지구 표면처럼 '구부러진' 공간입니다. 이런 공간을 **매니폴드 (Manifold)** 라고 부릅니다.

**문제점**: 구부러진 공간에서는 일반적인 덧셈, 뺄셈이 의미가 없습니다. (예: 두 회전 행렬을 더하면 더 이상 회전 행렬이 아님) 하지만 우리가 사용할 최적화 알고리즘 (예: Gauss-Newton) 은 변수들이 평평한 벡터 공간에 있다고 가정합니다.

**해결책**: **접선 공간 (Tangent Space)** 을 도입합니다.

-   **매니폴드 (Manifold)**: 우리가 다루는 실제 공간 (예: 모든 가능한 회전들의 집합).
-   **접선 공간 (Tangent Space)**: 매니폴드의 한 점 (현재의 추정치) 에 접하는 '평평한' 벡터 공간입니다. 이 공간에서는 벡터의 덧셈, 뺄셈이 가능합니다. 최적화 과정에서 계산되는 작은 변화량 ($\Delta \\mathbf{x}$) 이 바로 이 접선 공간의 벡터입니다. $SO(3)$ 의 접선 공간은 $\\mathfrak{so}(3)$ , $SE(3)$ 의 접선 공간은 $\\mathfrak{se}(3)$ 라고 표기합니다.

> 💡 **핵심 비유**: 지구 (매니폴드) 위를 걷는다고 상상해보세요. 지구 전체는 둥글지만, 당신이 서 있는 주변의 작은 영역 (접선 공간) 은 평평해 보입니다. 우리는 이 '평평한' 공간에서 움직임을 계산한 뒤, 그 결과를 다시 '둥근' 지구 위로 옮깁니다.

-   **Exponential Map (`exp`)**: 접선 공간의 벡터 (작은 변화량) 를 매니폴드 위의 실제 변환으로 매핑합니다.
    -   $\\mathfrak{so}(3) \\rightarrow SO(3)$: 회전 벡터를 회전 행렬/쿼터니언으로 변환.
-   **Logarithm Map (`log`)**: 매니폴드 위의 두 점 사이의 차이를 접선 공간의 벡터로 매핑합니다.
    -   $SO(3) \\rightarrow \\mathfrak{so}(3)$: 회전 행렬/쿼터니언을 회전 벡터로 변환.

### [실습 연결]
`chapter01` 노트북의 **3. Tangent Space와 Manifold** 섹션에서는 `exp` 와 `log` 연산을 코드로 구현하고, 이를 통해 최적화에서 포즈를 어떻게 업데이트하는지 (`retract` 연산) 실습합니다. 이 개념은 앞으로 배울 모든 최적화 과정의 기초가 됩니다.