# PGO 101 - Chapter 3 이론 강의: SymForce와 기호 연산의 힘

**강의 목표:** 이 강의를 마치면, 여러분은 SLAM 최적화에서 가장 어렵고 오류가 발생하기 쉬운 부분인 **야코비안 (Jacobian) 계산**을 SymForce를 통해 얼마나 쉽고, 빠르고, 정확하게 해결할 수 있는지 이해하게 됩니다. 기호 연산 (Symbolic Computation) 의 기본 개념을 배우고, 이를 통해 복잡한 3D 변환을 다루며, 최종적으로는 고성능 코드를 자동으로 생성하는 SymForce의 강력함을 체감하게 될 것입니다. 이 강의는 `chapter03_symforce_symbolic_computation.ipynb` 실습을 위한 핵심 이론을 제공합니다.

---

## 1. 계산의 두 가지 패러다임: 수치 연산 vs. 기호 연산

우리가 일반적으로 프로그래밍에서 사용하는 계산은 **수치 연산 (Numeric Computation)** 입니다. 변수에 구체적인 숫자를 할당하고 그 결과를 계산합니다.

```python
# 수치 연산
x = 2.0
y = 3.0
f = x**2 + y  # f의 값은 7.0
```

반면, **기호 연산 (Symbolic Computation)** 은 숫자 대신 수식 자체를 다룹니다. 변수는 값이 아닌 '기호'로 취급됩니다.

```python
# 기호 연산 (SymForce 사용)
import symforce.symbolic as sf
x = sf.Symbol('x')
y = sf.Symbol('y')
f = x**2 + y  # f는 'x**2 + y'라는 수식 그 자체
```

### 1.1. 왜 SLAM에서 기호 연산이 강력한가?

SLAM 최적화는 비용 함수를 최소화하는 과정이며, 이를 위해서는 비용 함수의 **도함수 (Derivative)**, 즉 **야코비안 (Jacobian)** 이 반드시 필요합니다. 야코비안은 "입력 변수 (로봇의 자세) 가 약간 변할 때, 출력 (에러 값) 이 얼마나 변하는가?"를 나타내는 행렬입니다.

야코비안을 계산하는 세 가지 방법이 있습니다.

*   **수동 계산 (Manual Differentiation)**: 사람이 직접 미분 공식을 적용하여 야코비안 수식을 유도하고 코드로 구현합니다. 3D 변환과 관련된 야코비안은 매우 복잡하여, 이 과정은 많은 시간이 소요되고 실수가 발생하기 매우 쉽습니다.
*   **수치 미분 (Numerical Differentiation)**: `(f(x+h) - f(x-h)) / 2h` 와 같이 작은 변화량 `h` 를 주어 함수의 변화를 근사적으로 계산합니다. 구현은 쉽지만, `h` 값 선택에 따라 정확도가 크게 달라지고 계산 비용이 높다는 단점이 있습니다.
*   **��동 미분 (Automatic Differentiation)**: 기호 연산 도구가 이 방법을 사용합니다. 수식의 구조를 분석하여 미분 규칙을 **정확하게** 연쇄적으로 적용 (Chain Rule) 합니다. 이는 수치 미분처럼 근사가 아니며, 수동 계산처럼 사람의 실수가 개입되지 않습니다.

> 💡 **핵심 비유**: 여러분이 복잡한 기계의 설계도 (수식) 를 가지고 있다고 상상해보세요.
> - **수치 미분**: 기계를 살짝 밀어보고 얼마나 움직이는지 측정하여 역학을 추정하는 것.
> - **기호 연산 (자동 미분)**: 설계도를 보고 각 부품이 어떻게 연결되어 있는지 분석하여 역학을 완벽하게 계산하는 것.

SymForce는 바로 이 자동 미분 방식을 사용하여 **100% 정확한 야코비안 수식**을 자동으로 유도해줍니다.

## 2. SymForce의 핵심 기능

### 2.1. 기호 객체와 자동 미분

SymForce는 스칼라 (`sf.Symbol`) 뿐만 아니라, 로보틱스에 필수적인 기하학적 객체들 (벡터 `sf.V3`, 회전 `sf.Rot3`, 자세 `sf.Pose3`) 을 기호적으로 다룰 수 있는 강력한 기능을 제공합니다. 이는 $SO(3)$ 나 $SE(3)$ 와 같은 매니폴드 위에서의 연산을 추상화하여 사용자가 복잡한 Lie Theory를 직접 다루지 않아도 되게 해줍니다.

-   **`.diff(x)`**: 스칼라 함수를 특정 변수 `x` 에 대해 미분합니다.
-   **`.jacobian(x)`**: 벡터 함수를 특정 벡터 변수 `x` 에 대해 편미분하여 야코비안 행렬을 구합니다.

### 2.2. 코드 생성 (Code Generation)

SymForce의 가장 강력한 기능 중 하나는, 유도된 기호적 표현식 (예: 에러 함수와 그 야코비안) 을 매우 최적화된 코드로 자동 변환하는 것입니다.

-   **최적화**: **공통 부분 표현식 제거 (Common Subexpression Elimination, CSE)** 와 같은 기법을 통해 중복 계산을 없애고 코드 실행 효율을 극대화합니다. 예를 들어, `sin(theta)` 가 수식 여러 곳에 나타나면, 이를 한 번만 계산하여 변수에 저장한 뒤 재사용하는 코드를 생성합니다.
-   **다중 언어 지원**: 동일한 기호 표현식으로부터 Python, C++, 심지어 CUDA 코드까지 생성할 수 있어, 빠른 프로토타이핑과 고성능 배포를 동시에 만족시킵니다.

### [실습 연결]
`chapter03` 노트북에서는 다음을 실습합니다:
- **1. Symbolic 변수와 표현식**: `sf.Symbol` 과 `sf.V3` 를 만들어보고, 이를 조합해 수식을 만듭니다.
- **1.2 자동 미분**: `.diff()` 와 `.jacobian()` 을 사용하여 스칼라/벡터 함수의 도함수를 직접 계산해봅니다.
- **2. Lie Group 연산**: `sf.Rot3`, `sf.Pose3` 와 같은 기하학적 객체를 기호적으로 다루고, 이들의 합성과 ���변환을 수행합니다.
- **3. Relative Pose Error**: ch1에서 배운 상대 포즈 에러 수식을 SymForce로 표현하고, 각 포즈에 대한 야코비안을 자동으로 계산합니다.
- **4. Codegen**: 방금 만든 에러 함수와 야코비안을 계산하는 고성능 Python 함수를 자동으로 생성하고, 원래의 기호적 계산과 성능을 비교하여 수십 배의 속도 향상을 확인합니다.

---

## 3. 수치 안정성: Epsilon의 역할

카메라 모델의 투영 수식 `u = f * X / Z` 에서 만약 `Z` 가 0에 가까워지면 어떻게 될까요? 컴퓨터는 0으로 나누는 연산을 수행할 수 없어 프로그램이 중단됩니다.

**Epsilon ($\epsilon$)** 은 이러한 수치적 특이점 (singularity) 을 피하기 위해 더해주는 아주 작은 값입니다.

*   **잘못된 방법**: `Z_safe = Z + epsilon`
    *   만약 `Z` 가 음수이고 `epsilon` 과 크기가 같다면, `Z_safe` 는 다시 0이 될 수 있습니다.
*   **올바른 방법 (SymForce 패턴)**: `Z_safe = Z + epsilon * sf.sign_no_zero(Z)`
    *   `sf.sign_no_zero(Z)` 는 `Z` 의 부호를 반환하되, `Z=0` 일 때는 +1을 반환합니다.
    *   이를 통해 `Z` 가 0에 가까워질 때 항상 0에서 멀어지는 방향으로 `epsilon` 을 더해주어 안정성을 확보합니다.

SymForce는 이러�� `epsilon` 처리를 프레임워크 수준에서 내장하고 있어, 개발자가 복잡한 예외 처리를 하지 않아도 강건한 코드를 작성할 수 있도록 돕습니다.
