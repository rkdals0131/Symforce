
# PGO 101 - Chapter 3 이론 강의: SymForce와 기호 연산의 힘

**강의 목표:** 이 강의를 마치면, 여러분은 SLAM 최적화에서 가장 어렵고 오류가 발생하기 쉬운 부분인 **야코비안(Jacobian) 계산**을 SymForce를 통해 얼마나 쉽고, 빠르고, 정확하게 해결할 수 있는지 이해하게 됩니다. 기호 연산(Symbolic Computation)의 기본 개념을 배우고, 이를 통해 복잡한 3D 변환을 다루며, 최종적으로는 고성능 코드를 자동으로 생성하는 SymForce의 강력함을 체감하게 될 것입니다. 이 강의는 `chapter03_symforce_symbolic_computation.ipynb` 실습을 위한 핵심 이론을 제공합니다.

---

## 1. 계산의 두 가지 패러다임: 수치 연산 vs. 기호 연산

우리가 일반적으로 프로그래밍에서 사용하는 계산은 **수치 연산(Numeric Computation)**입니다.

```python
# 수치 연산
x = 2.0
y = 3.0
f = x**2 + y  # f의 값은 7.0
```

반면, **기호 연산(Symbolic Computation)**은 숫자 대신 수식 자체를 다룹니다.

```python
# 기호 연산 (SymForce 사용)
import symforce.symbolic as sf
x = sf.Symbol('x')
y = sf.Symbol('y')
f = x**2 + y  # f는 'x**2 + y'라는 수식 그 자체
```

### 왜 SLAM에서 기호 연산이 강력한가?

SLAM 최적화는 비용 함수를 최소화하는 과정이며, 이를 위해서는 비용 함수의 **도함수(Derivative)**, 즉 **야코비안(Jacobian)**이 반드시 필요합니다.

*   **수동 계산**: 3D 변환과 관련된 야코비안은 매우 복잡하여, 사람이 직접 유도하면 실수가 발생하기 쉽고 많은 시간이 소요됩니다.
*   **수치 미분**: `(f(x+h) - f(x-h)) / 2h`와 같이 근사치를 계산하는 방식으로, 구현은 쉽지만 정확도가 낮고 계산 비용이 높습니다.
*   **기호 연산 (자동 미분)**: SymForce는 수식 자체를 알고 있으므로, 미분 규칙에 따라 **100% 정확한 야코비안 수식**을 자동으로 유도해줍니다.

> 💡 **핵심 비유**: 여러분이 복잡한 기계의 설계도(수식)를 가지고 있다고 상상해보세요.
> - **수치 미분**: 기계를 살짝 밀어보고 얼마나 움직이는지 측정하여 역학을 추정하는 것.
> - **기호 연산**: 설계도를 보고 각 부품이 어떻게 연결되어 있는지 분석하여 역학을 완벽하게 계산하는 것.

## 2. SymForce의 핵심 기능

### 개념 트리: SymForce의 능력

*   **기호 연산 (Symbolic Computation)**
    *   **기호 변수**: `sf.Symbol`, `sf.V3`, `sf.Rot3`, `sf.Pose3` 등 (ch3)
        *   *선수 지식*: 변수, 벡터, 행렬, 3D 변환(ch1)
    *   **자동 미분 (Automatic Differentiation)**
        *   **`.diff(x)`**: 스칼라 함수 미분
        *   **`.jacobian(x)`**: 벡터 함수 미분 (야코비안 계산)
    *   **코드 생성 (Code Generation)**
        *   **최적화**: 공통 부분 표현식 제거(CSE) 등
        *   **결과**: Python 함수 -> 고성능 C++/Python 코드로 자동 변환

### [실습 연결]
`chapter03` 노트북에서는 다음을 실습합니다:
- **1. Symbolic 변수와 표현식**: `sf.Symbol`과 `sf.V3`를 만들어보고, 이를 조합해 수식을 만듭니다.
- **1.2 자동 미분**: `.diff()`와 `.jacobian()`을 사용하여 스칼라/벡터 함수의 도함수를 직접 계산해봅니다.
- **2. Lie Group 연산**: `sf.Rot3`, `sf.Pose3`와 같은 기하학적 객체를 기호적으로 다루고, 이들의 합성과 역변환을 수행합니다.
- **3. Relative Pose Error**: ch1에서 배운 상대 포즈 에러 수식을 SymForce로 표현하고, 각 포즈에 대한 야코비안을 자동으로 계산합니다.
- **4. Codegen**: 방금 만든 에러 함수와 야코비안을 계산하는 고성능 Python 함수를 자동으로 생성하고, 원래의 기호적 계산과 성능을 비교하여 수십 배의 속도 향상을 확인합니다.

---

## 3. 수치 안정성: Epsilon의 역할

카메라 모델의 투영 수식 `u = f * X / Z` 에서 만약 `Z`가 0에 가까워지면 어떻게 될까요? 컴퓨터는 0으로 나누는 연산을 수행할 수 없어 프로그램이 중단됩니다.

**Epsilon($\epsilon$)**은 이러한 수치적 특이점(singularity)을 피하기 위해 더해주는 아주 작은 값입니다.

*   **잘못된 방법**: `Z_safe = Z + epsilon`
    *   만약 `Z`가 음수이고 `epsilon`과 크기가 같다면, `Z_safe`는 다시 0이 될 수 있습니다.
*   **올바른 방법 (SymForce 패턴)**: `Z_safe = Z + epsilon * sf.sign_no_zero(Z)`
    *   `sf.sign_no_zero(Z)`는 `Z`의 부호를 반환하되, `Z=0`일 때는 +1을 반환합니다.
    *   이를 통해 `Z`가 0에 가까워질 때 항상 0에서 멀어지는 방향으로 `epsilon`을 더해주어 안정성을 확보합니다.

SymForce는 이러한 `epsilon` 처리를 내장하고 있어, 개발자가 복잡한 예외 처리를 하지 않아도 강건한 코드를 작성할 수 있도록 돕습니다.
