# PGO 101 - Chapter 5 이론 강의: 야코비안 계산 - 수동의 고통 vs. 자동의 희열

**강의 목표:** 이 강의를 마치면, 여러분은 Pose Graph Optimization의 성능과 정확도를 좌우하는 가장 핵심적인 요소인 **야코비안 (Jacobian)** 에 대해 깊이 있게 이해하게 됩니다. 야코비안을 수동으로 유도하고 구현하는 것이 왜 그렇게 어렵고 오류가 발생하기 쉬운지, 그리고 SymForce와 같은 자동 미분 도구가 이 문제를 어떻게 해결하여 우리의 삶을 편하게 만들어주는지 명확히 비교하고 설명할 수 있게 됩니다. 이 강의는 `chapter05_jacobian_manual_vs_automatic.ipynb` 실습에서 두 가지 방식의 차이를 코드로 직접 확인하기 위한 이론적 토대를 제공합니다.

---

## 1. 야코비안이란 무엇인가? - 선형 근사의 마법

최적화 이론에서 야코비안의 역할을 이해하기 위해, 먼저 고등학교에서 배운 '미분'의 개념부터 시작하겠습니다.

### 1.1. 선수 지식: 미분에서 시작하기

변수가 하나인 함수 $f(x)$ 에서, 특정 지점 $x_0$ 에서의 미분 계수 $f'(x_0)$ 는 무엇을 의미할까요? 바로 **"점 $x_0$ 에서 함수 $f(x)$ 를 가장 잘 근사하는 직선의 기울기"** 입니다. 즉, 아주 작은 $\Delta x$ 에 대해 다음과 같은 선형 근사가 가능합니다.

$$ f(x_0 + \Delta x) \approx f(x_0) + f'(x_0) \Delta x $$

이것이 바로 **1차 테일러 근사 (Taylor Approximation)** 입니다.

### 1.2. 선수 지식: 다변수 함수와 편미분

이제 이 개념을 SLAM 문제처럼 여러 개의 입력과 여러 개의 출력을 갖는 다변수 벡터 함수 $\mathbf{f}(\mathbf{x})$ 로 확장해 봅시다. 여기서 $\mathbf{x} \in \mathbb{R}^n$ 는 입력 벡터 (예: 모든 로봇의 자세), $\mathbf{f} \in \mathbb{R}^m$ 는 출력 벡터 (예: 모든 측정 에러) 입니다.

이 경우, '기울기'의 개념은 더 이상 하나의 숫자가 아닌, **행렬**로 확장됩니다. 먼저 **편미분 (Partial Derivative)** 의 개념을 알아야 합니다. 편미분 $\frac{\partial f_i}{\partial x_j}$ 는 여러 입력 변수 중 오직 $x_j$ 하나만 변할 때, 특정 출력 $f_i$ 가 얼마나 변하는지를 나타냅니다. 다른 모든 입력 변수는 상수처럼 취급합니다.

### 1.3. 야코비안 행렬의 정의

**야코비안 행렬 (Jacobian Matrix)** $J$ 는 이 모든 편미분 값들을 모아놓은 행렬입니다. 만약 함수가 $m$ 개의 출력과 $n$ 개의 입력을 갖는다면, 야코비안은 $m \times n$ 크기의 행렬이 됩니다.

$$
J = \begin{bmatrix}
\frac{\partial f_1}{\partial x_1} & \cdots & \frac{\partial f_1}{\partial x_n} \\
\vdots & \ddots & \vdots \\
\frac{\partial f_m}{\partial x_1} & \cdots & \frac{\partial f_m}{\partial x_n}
\end{bmatrix}
$$

이 야코비안 행렬이 바로 다변수 함수에 대한 **"가장 좋은 선형 근사"** 역할을 합니다. 단일 변수 함수에서와 마찬가지로, 특정 지점 $\mathbf{x}_0$ 에서의 1차 테일러 근사는 다음과 같이 표현됩니다.

$$ \mathbf{f}(\mathbf{x}_0 + \Delta\mathbf{x}) \approx \mathbf{f}(\mathbf{x}_0) + J(\mathbf{x}_0) \Delta\mathbf{x} $$

### 1.4. SLAM에서의 야코비안

이 개념을 SLAM 문제에 적용해 봅시다.
-   **입력 $\mathbf{x}$**: 모든 로봇의 자세 (수백, 수천 개의 변수)
-   **출력 $\mathbf{f}(\mathbf{x})$**: 모든 센서 측정 에러 (수백, 수천 개의 에러 값)

따라서 SLAM에서의 야코비안은 **"로봇의 자세를 약간 수정했을 때, 각 센서 측정 에러가 어떻게 변하는가"** 를 나타내는 거대한 행렬입니다. 최적화 알고리즘 (Gauss-Newton) 은 이 야코비안 정보를 사용하여 에러를 가장 효과적으로 줄일 수 있는 업데이트 방향 $\Delta\mathbf{x}$ 를 계산합니다.

---

## 2. 수동 야코비안 계산: 매니폴드 위에서의 미분

Between Factor의 에러 함수는 다음과 같이 정의됩니다.

$$ \mathbf{e}_{ij} = \log(T_{ij}^{\text{meas}^{-1}} \cdot T_i^{-1} \cdot T_j) $$

이 함수를 $T_i$ 와 $T_j$ 에 대해 미분하는 것은 왜 그렇게 어려울까요?

### 2.1. 선수 지식: 리 그룹과 리 대수

Chapter 1에서 배웠듯이, 회전 ($SO(3)$) 과 자세 ($SE(3)$) 는 **리 그룹 (Lie Group)** 이라는 특별한 매니폴드입니다. 이 공간은 덧셈과 뺄셈이 정의되지 않는 '구부러진' 공간입니다. 반면, 이들의 **접선 공간 (Tangent Space)** 은 우리가 잘 아는 벡터 공간이며, 각각 **리 대수 (Lie Algebra)** $\mathfrak{so}(3)$, $\mathfrak{se}(3)$ 라고 불립니다.

최적화 업데이트 ($\Delta\mathbf{x}$) 는 리 대수 위에서 계산되고, `exp` 맵을 통해 리 그룹으로 다시 매핑됩니다. 수동으로 야코비안을 계산하려면 이 두 공간 사이의 미분 관계를 정확히 이해해야 합니다.

### 2.2. 수동 계산의 함정들

1.  **리 대수에서의 연쇄 법칙 (Chain Rule on Lie Algebra)**: 위 에러 함수는 여러 $SE(3)$ 변환의 합성으로 이루어져 있습니다. 이를 미분하려면 일반적인 체인 룰이 아닌, 리 대수 위에서의 복잡한 연쇄 법칙을 적용해야 합니다. 이 과정에는 **Adjoint 행렬**과 같은 추가적인 개념이 필요하여 매우 복잡합니다.
2.  **곱셈과 역행렬의 미분**: $T_i^{-1}$ 와 같은 역행렬의 미분과, 여러 행렬 곱의 미분은 매우 까다롭고 실수하기 쉽습니다.
3.  **좌표계 변환**: 각 변환은 다른 좌표계에서의 연산을 의미하므로, 미분 과정에서 좌표계 변환을 정확히 고려해야 합니다.

### [실습 연결]
`chapter05` 노트북의 **1. 수동 Jacobian 계산 - 근사 방법** 과 **2. 수동 Jacobian 계산 - 정확한 방법** 섹션에서는, 이 고통스러운 과정을 직접 코드로 구현해봅니다. 이를 통해 수동 계산이 얼마나 복잡하고 어려운지 직접 체감하게 될 것입니다.

---

## 3. 자동 야코비안 계산: SymForce가 선사하는 희열

SymForce와 같은 기호 연산 도구는 이 모든 고통을 해결해줍니다.

### 3.1. 계산 그래프와 자동 미분

SymForce는 우리가 정의한 에러 함수를 단순한 숫자 계산이 아닌, 기본 연산자 (+, -, *, /, sin, cos 등) 들로 구성된 **계산 그래프 (Computational Graph)** 로 이해합니다.

자동 미분은 이 그래프를 따라가며 각 노드에서의 미분 값을 계산하고, 이를 **연쇄 법칙**에 따라 끝에서부터 시작까지 (Reverse Mode) 또는 시작부터 끝까지 (Forward Mode) 조합하여 전체 함수의 미분을 정확하게 계산합니다.

### 3.2. Storage vs. Tangent Space 야코비안

최적화는 최소 표현인 **tangent space** (예: 3D 회전 벡터) 에서 수행되지만, 상태는 종종 과다 표현된 **storage space** (예: 4D 쿼터니언) 에 저장됩니다. 따라서 우리가 정말 필요한 야코비안은 $\frac{\partial \text{error}}{\partial \text{tangent}}$ 입니다. 이를 계산하려면 체인 룰에 의해 다음과 같은 변환이 필요합니다.

$$ \frac{\partial \text{error}}{\partial \text{tangent}} = \frac{\partial \text{error}}{\partial \text{storage}} \cdot \frac{\partial \text{storage}}{\partial \text{tangent}} $$

SymForce는 이 복잡한 변환 야코비안 ($\frac{\partial \text{storage}}{\partial \text{tangent}}$) 을 내부적으로 모두 알고 있고, 자동으로 처리해줍니다. 이것이 SymForce가 Lie Group 연산을 매우 편리하게 다룰 수 있는 비결입니다.

### [실습 연결]
`chapter05` 노트북의 **3. SymForce를 사용한 자동 Jacobian** 섹션에서는, 단 몇 줄의 코드로 야코비안을 계산하는 함수를 생성합니다. 그리고 **4. 성능 비교** 와 **5. 정확도 비교** 섹션에서 수동 방식과 SymForce 방식의 실행 시간과 정확도를 직접 비교하며 그 압도적인 효율성을 확인합니다.