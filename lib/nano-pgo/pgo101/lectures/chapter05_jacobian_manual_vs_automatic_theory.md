
# PGO 101 - Chapter 5 이론 강의: 야코비안 계산 - 수동의 고통 vs. 자동의 희열

**강의 목표:** 이 강의를 마치면, 여러분은 Pose Graph Optimization의 성능과 정확도를 좌우하는 가장 핵심적인 요소인 **야코비안(Jacobian)**에 대해 깊이 있게 이해하게 됩니다. 야코비안을 수동으로 유도하고 구현하는 것이 왜 그렇게 어렵고 오류가 발생하기 쉬운지, 그리고 SymForce와 같은 자동 미분 도구가 이 문제를 어떻게 해결하여 우리의 삶을 편하게 만들어주는지 명확히 비교하고 설명할 수 있게 됩니다. 이 강의는 `chapter05_jacobian_manual_vs_automatic.ipynb` 실습에서 두 가지 방식의 차이를 코드로 직접 확인하기 위한 이론적 토대를 제공합니다.

---

## 1. 야코비안: 최적화의 네비게이션

Chapter 4에서 우리는 최적화가 $H \Delta x = -b$ 라는 선형 시스템을 반복적으로 푸는 과정임을 배웠습니다. 여기서 $H$와 $b$를 구성하는 핵심 재료가 바로 **야코비안($J$)**입니다.

$$ H = \sum J^T \Omega J \quad \quad b = \sum J^T \Omega e $$

야코비안은 비용 함수 표면의 '기울기' 정보를 담고 있어, 최적화 알고리즘에게 **"에러를 줄이려면 어느 방향으로 가야 하는가?"** 를 알려주는 네비게이션과 같은 역할을 합니다.

- **정확한 야코비안**: 최적해를 향한 가장 빠른 지름길을 알려줍니다. → **빠른 수렴, 정확한 결과**
- **부정확한 야코비안**: 엉뚱한 길을 알려주거나 길을 잃게 만듭니다. → **느린 수렴, 잘못된 결과, 또는 발산**

따라서, 정확한 야코비안을 계산하는 것은 SLAM 시스템의 성능과 직결되는 매우 중요한 문제입니다.

## 2. 수동 야코비안 계산: 고통의 길

Between Factor의 에러 함수는 다음과 같이 정의됩니다.

$$ e_{ij} = \log(T_{ij}^{meas^{-1}} \cdot T_i^{-1} \cdot T_j) $$

이 복잡한 행렬 함수를 $T_i$와 $T_j$에 대해 각각 편미분하여 야코비안을 유도하는 것은 험난한 과정입니다.

### 왜 어려운가? - 수동 계산의 함정들

1.  **리 이론(Lie Theory)의 복잡성**: $SO(3), SE(3)$는 단순한 벡터 공간이 아닌 매니폴드(Manifold)이므로, 미분을 위해 `exp/log map`, `Adjoint`, `right/left Jacobian` 등 복잡한 수학적 도구가 필요합니다.
2.  **체인 룰(Chain Rule)의 지옥**: 에러 함수는 여러 함수의 합성으로 이루어져 있어, 체인 룰을 적용하는 과정이 매우 길고 복잡합니다.
3.  **좌표계의 혼동**: 월드 좌표계, 로컬 좌표계, 바디 좌표계 등 여러 좌표계가 섞여 있어 변환 과정에서 실수하기 쉽습니다.
4.  **구현의 어려움**: 유도한 수식을 코드로 옮기는 과정에서 부호나 인덱스 오류가 발생하기 매우 쉽습니다.

### [실습 연결]
`chapter05` 노트북의 **1. 수동 Jacobian 계산 - 근사 방법**과 **2. 수동 Jacobian 계산 - 정확한 방법** 섹션에서는, 이 고통스러운 과정을 직접 코드로 구현해봅니다. 이를 통해 수동 계산이 얼마나 복잡하고 어려운지 직접 체감하게 될 것입니다.

---

## 3. 자동 야코비안 계산: SymForce가 선사하는 희열

SymForce와 같은 기호 연산 도구는 이 모든 고통을 해결해줍니다.

### 어떻게 가능한가?

SymForce는 우리가 정의한 에러 함수를 단순한 숫자 계산이 아닌, **수학적 표현식 그 자체**로 이해합니다.

```python
# SymForce는 이 코드를 '수식'으로 이해한다
T_error = Tij_measured.inverse() * Ti.inverse() * Tj
error_tangent = T_error.to_tangent()
```

컴퓨터는 이미 기본적인 미분 규칙(예: $x^2$의 미분은 $2x$)과 행렬 미분에 대한 체인 룰을 알고 있습니다. SymForce는 이 규칙들을 우리가 정의한 복잡한 ��식에 **기계적으로, 그리고 완벽하게** 적용하여 최종적인 야코비안 수식을 자동으로 유도합니다.

### SymForce를 사용한 자동 미분의 장점

1.  **정확성**: 사람의 실수(Human Error)가 개입할 여지가 없으므로, 100% 정확한 야코비안을 보장합니다.
2.  **개발 속도**: 복잡한 수학 유도에 시간을 쏟을 필요 없이, 모델링에만 집중할 수 있습니다. 모델이 변경되어도 코드를 단 한 줄만 수정하면 됩니다.
3.  **최적화된 코드 생성**: SymForce의 `codegen` 기능은 유도된 야코비안을 계산하는 매우 효율적인 C++ 또는 Python 코드를 자동으로 생성해줍니다. 이는 사람이 직접 최적화한 코드보다 더 빠를 수도 있습니다.

### [실습 연결]
`chapter05` 노트북의 **3. SymForce를 사용한 자동 Jacobian** 섹션에서는, 단 몇 줄의 코드로 야코비안을 계산하는 함수를 생성합니다. 그리고 **4. 성능 비교**와 **5. 정확도 비교** 섹션에서 수동 방식과 SymForce 방식의 실행 시간과 정확도를 직접 비교하며 그 압도적인 효율성을 확인합니다.
